name: Deploy Telegram Bot to Azure Container Apps

on:
  release:
    types: [prereleased, released]
  push:
    branches: [master, prod, develop, test]
  pull_request:
    types: [closed]
    branches: [master, prod, develop, test]

permissions: 
  contents: read
  
env:
  ACR_NAME: ca20a502fbd8acr
  RESOURCE_GROUP: container-app-rsgp
  BRANCHED_CONTAINER_APP_NAME: branched-container-app-bot
  PROD_CONTAINER_APP_NAME: m21-live

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3


      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ steps.set_deployment_info.outputs.IS_PROD == 'true' && secrets.AZURE_CREDENTIALS_M21LIVE || secrets.AZURE_CREDENTIALS }}

          
      - name: Set deployment info
        id: set_deployment_info
        run: |
          # First determine if this is a release
          if [ "${{ github.event_name }}" == "release" ]; then
            # Get the release tag
            TAG_NAME="${{ github.event.release.tag_name }}"
            echo "RELEASE_TAG=${TAG_NAME}" >> $GITHUB_OUTPUT
            
            # Set image tag based on release tag
            echo "IMAGE_TAG=${TAG_NAME}" >> $GITHUB_OUTPUT
            
            # Set other variables based on the target branch
            TARGET_BRANCH="${{ github.event.release.target_commitish }}"
            case "$TARGET_BRANCH" in
              "prod")
                echo "CONTAINER_NAME=container-app-bot-prod" >> $GITHUB_OUTPUT
                echo "STAGE=prod" >> $GITHUB_OUTPUT
                echo "BOT_TOKEN_SECRET=prod-bot-token" >> $GITHUB_OUTPUT
                echo "CONTAINER_APP_NAME=${{ env.PROD_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
                echo "IS_PROD=true" >> $GITHUB_OUTPUT
                echo "MIN_REPLICAS=1" >> $GITHUB_OUTPUT
                echo "MAX_REPLICAS=10" >> $GITHUB_OUTPUT
                ;;
              "develop")
                echo "CONTAINER_NAME=container-app-bot-dev" >> $GITHUB_OUTPUT
                echo "STAGE=dev" >> $GITHUB_OUTPUT
                echo "BOT_TOKEN_SECRET=dev-bot-token" >> $GITHUB_OUTPUT
                echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
                echo "IS_PROD=false" >> $GITHUB_OUTPUT
                echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
                echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
                ;;
              "test")
                echo "CONTAINER_NAME=container-app-bot-test" >> $GITHUB_OUTPUT
                echo "STAGE=test" >> $GITHUB_OUTPUT
                echo "BOT_TOKEN_SECRET=test-bot-token" >> $GITHUB_OUTPUT
                echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
                echo "IS_PROD=false" >> $GITHUB_OUTPUT
                echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
                echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
                ;;
              *)
                echo "Error: Releases are only supported from develop, test, or prod branches"
                exit 1
                ;;
            esac
            
          else
            # Handle non-release deployments
            if [[ "${{ github.ref }}" == "refs/heads/prod" ]]; then
              echo "CONTAINER_NAME=container-app-bot-prod" >> $GITHUB_OUTPUT
              echo "STAGE=prod" >> $GITHUB_OUTPUT
              echo "BOT_TOKEN_SECRET=prod-bot-token" >> $GITHUB_OUTPUT
              echo "CONTAINER_APP_NAME=${{ env.PROD_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
              echo "IS_PROD=true" >> $GITHUB_OUTPUT
              echo "IMAGE_TAG=prod-latest" >> $GITHUB_OUTPUT
              echo "MIN_REPLICAS=1" >> $GITHUB_OUTPUT
              echo "MAX_REPLICAS=10" >> $GITHUB_OUTPUT
            else
              case "${{ github.ref }}" in
                "refs/heads/develop")
                  echo "CONTAINER_NAME=container-app-bot-dev" >> $GITHUB_OUTPUT
                  echo "STAGE=dev" >> $GITHUB_OUTPUT
                  echo "BOT_TOKEN_SECRET=dev-bot-token" >> $GITHUB_OUTPUT
                  echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
                  echo "IS_PROD=false" >> $GITHUB_OUTPUT
                  echo "IMAGE_TAG=dev-latest" >> $GITHUB_OUTPUT
                  echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
                  echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
                  ;;
                "refs/heads/test")
                  echo "CONTAINER_NAME=container-app-bot-test" >> $GITHUB_OUTPUT
                  echo "STAGE=test" >> $GITHUB_OUTPUT
                  echo "BOT_TOKEN_SECRET=test-bot-token" >> $GITHUB_OUTPUT
                  echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
                  echo "IS_PROD=false" >> $GITHUB_OUTPUT
                  echo "IMAGE_TAG=test-latest" >> $GITHUB_OUTPUT
                  echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
                  echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
                  ;;
                "refs/heads/master")
                  echo "CONTAINER_NAME=container-app-bot-staging" >> $GITHUB_OUTPUT
                  echo "STAGE=staging" >> $GITHUB_OUTPUT
                  echo "BOT_TOKEN_SECRET=master-bot-token" >> $GITHUB_OUTPUT
                  echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
                  echo "IS_PROD=false" >> $GITHUB_OUTPUT
                  echo "IMAGE_TAG=staging-latest" >> $GITHUB_OUTPUT
                  echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
                  echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
                  ;;
                *)
                  echo "Unsupported branch"
                  exit 1
                  ;;
              esac
            fi
          fi

          # Set release tag for non-release events
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "RELEASE_TAG=pushed-into-${{ github.ref_name }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "RELEASE_TAG=merged-into-${{ github.base.ref }}" >> $GITHUB_OUTPUT
          else
            echo "RELEASE_TAG=manual-trigger" >> $GITHUB_OUTPUT
          fi

      - name: Build and push image to ACR
        run: |
          # Clean up old images with the same tag
          az acr repository delete \
            --name ${{ env.ACR_NAME }} \
            --image ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
            --yes || true

          # Build and push new image
          az acr build \
            --registry ${{ env.ACR_NAME }} \
            --image ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
            --file Dockerfile \
            .

      - name: Manage Container App Revisions
        run: |
              # Get timestamp for new revision
              TIMESTAMP=$(date +%Y%m%d%H%M%S)
              NEW_REVISION="${{ steps.set_deployment_info.outputs.STAGE }}-${TIMESTAMP}"
              
              if [ "${{ steps.set_deployment_info.outputs.IS_PROD }}" == "true" ]; then
                # Production container app configuration
                API_ID_SECRET="apiid"
                API_HASH_SECRET="apihash"
                BOT_TOKEN_SECRET="bottokern"
                
                # Get current active revision
                CURRENT_REVISION=$(az containerapp revision list \
                  -n ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  -g ${{ env.RESOURCE_GROUP }} \
                  --query "[?properties.active].name" -o tsv)
                
                echo "Current active revision: $CURRENT_REVISION"
                
                # Create new revision with 0 traffic
                echo "Creating new revision: ${NEW_REVISION}"
                az containerapp update \
                  --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --revision-suffix "${NEW_REVISION}" \
                  --container-name container-app-bot-prod \
                  --image ${{ env.ACR_NAME }}.azurecr.io/container-app-bot-prod:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
                  --cpu 0.5 --memory 1.0Gi \
                  --min-replicas 1 \
                  --max-replicas 10 \
                  --set-env-vars \
                    "RELEASE_TAG=${{ steps.set_deployment_info.outputs.RELEASE_TAG }}" \
                    "STAGE=${{ steps.set_deployment_info.outputs.STAGE }}" \
                    "PYTHONUNBUFFERED=1" \
                    "BOT_TOKEN=secretref:${BOT_TOKEN_SECRET}" \
                    "API_ID=secretref:${API_ID_SECRET}" \
                    "API_HASH=secretref:${API_HASH_SECRET}" \
                  --traffic-weight ${NEW_REVISION}=0
    
                # Wait for new revision to be ready
                echo "Waiting for new revision to be ready..."
                sleep 30
                
                # Check if new revision is healthy
                REVISION_STATUS=$(az containerapp revision show \
                  -n ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  -g ${{ env.RESOURCE_GROUP }} \
                  --revision ${NEW_REVISION} \
                  --query "properties.status" -o tsv)
                  
                if [ "$REVISION_STATUS" == "Running" ]; then
                  echo "New revision is healthy. Switching traffic..."
                  
                  # Switch traffic to new revision
                  az containerapp revision activate \
                    --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                    --resource-group ${{ env.RESOURCE_GROUP }} \
                    --revision ${NEW_REVISION}
                    
                  echo "Traffic switched to new revision"
                  
                  # Deactivate old revision
                  if [ -n "$CURRENT_REVISION" ]; then
                    echo "Deactivating old revision: $CURRENT_REVISION"
                    az containerapp revision deactivate \
                      --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                      --resource-group ${{ env.RESOURCE_GROUP }} \
                      --revision $CURRENT_REVISION
                  fi
                  
                  # Clean up old revisions (keep only previous one)
                  echo "Cleaning up old revisions..."
                  az containerapp revision list \
                    -n ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                    -g ${{ env.RESOURCE_GROUP }} \
                    --query "[?properties.active==false].{name:name, createdTime:properties.createdTime} | sort_by(@, &createdTime)" -o json | \
                    jq -r '.[:-1][].name' | while read -r old_revision; do
                    if [ -n "$old_revision" ]; then
                      echo "Deleting old revision: $old_revision"
                      az containerapp revision delete \
                        --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                        --resource-group ${{ env.RESOURCE_GROUP }} \
                        --revision "$old_revision" --yes || true
                    fi
                  done
                else
                  echo "New revision is not healthy. Deployment failed."
                  exit 1
                fi
                
              else
                # Development container app configuration
                API_ID_SECRET="api-id"
                API_HASH_SECRET="api-hash"
                BOT_TOKEN_SECRET="${{ steps.set_deployment_info.outputs.BOT_TOKEN_SECRET }}"
                
                # Update Container App for development
                echo "Creating new revision: ${NEW_REVISION}"
                az containerapp update \
                  --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --revision-suffix "${NEW_REVISION}" \
                  --min-replicas ${{ steps.set_deployment_info.outputs.MIN_REPLICAS }} \
                  --max-replicas ${{ steps.set_deployment_info.outputs.MAX_REPLICAS }} \
                  --container-name ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }} \
                  --image ${{ env.ACR_NAME }}.azurecr.io/${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
                  --set-env-vars \
                    "RELEASE_TAG=${{ steps.set_deployment_info.outputs.RELEASE_TAG }}" \
                    "STAGE=${{ steps.set_deployment_info.outputs.STAGE }}" \
                    "PYTHONUNBUFFERED=1" \
                    "BOT_TOKEN=secretref:${BOT_TOKEN_SECRET}" \
                    "API_ID=secretref:${API_ID_SECRET}" \
                    "API_HASH=secretref:${API_HASH_SECRET}"
                
                # Wait for new revision to be ready
                sleep 30
                
                # For non-production, keep latest 3 revisions
                az containerapp revision list \
                  -n ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  -g ${{ env.RESOURCE_GROUP }} \
                  --query "[?contains(name, '${{ steps.set_deployment_info.outputs.STAGE }}-')].{name:name, createdTime:properties.createdTime} | sort_by(@, &createdTime)" -o json | \
                  jq -r '.[:-3][].name' | while read -r old_revision; do
                  if [ -n "$old_revision" ]; then
                    echo "Deleting old revision: $old_revision"
                    az containerapp revision delete \
                      --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                      --resource-group ${{ env.RESOURCE_GROUP }} \
                      --revision "$old_revision" --yes || true
                  fi
                done
              fi

