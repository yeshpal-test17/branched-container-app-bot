name: Deploy Telegram Bot to Azure Container Apps

on:
  release:
    types: [prereleased, released]
  push:
    branches: [master, prod]
  pull_request:
    types: [closed]
    branches: [master, prod, develop, test]

permissions: 
  contents: read
  
env:
  ACR_NAME: ca20a502fbd8acr
  RESOURCE_GROUP: container-app-rsgp
  BRANCHED_CONTAINER_APP_NAME: m21-development
  PROD_CONTAINER_APP_NAME: m21-live

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ steps.set_deployment_info.outputs.IS_PROD == 'true' && secrets.AZURE_CREDENTIALS_M21LIVE || secrets.M21_DEVELOPMENT_CONTAINERAPPBOTRELEASESP }}


      - name: Set deployment info
        id: set_deployment_info
        run: |
          # For releases, use the target branch and validate tag format
          if [ "${{ github.event_name }}" == "release" ]; then
            BRANCH_REF="refs/heads/${{ github.event.release.target_commitish }}"
            TAG_NAME="${{ github.event.release.tag_name }}"
            
            # Validate tag format based on branch
            if [[ "$BRANCH_REF" == "refs/heads/develop" ]]; then
              if [[ ! "$TAG_NAME" =~ ^alpha-[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "Error: Invalid tag format for develop branch. Must be 'alpha-x.y.z'"
                exit 1
              fi
              echo "RELEASE_TAG=${TAG_NAME}" >> $GITHUB_OUTPUT
              echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
            elif [[ "$BRANCH_REF" == "refs/heads/test" ]]; then
              if [[ ! "$TAG_NAME" =~ ^beta-[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "Error: Invalid tag format for test branch. Must be 'beta-x.y.z'"
                exit 1
              fi
              echo "RELEASE_TAG=${TAG_NAME}" >> $GITHUB_OUTPUT
              echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
            else
              echo "Error: Releases are only allowed from develop or test branches."
              exit 1
            fi
          else
            BRANCH_REF="${{ github.ref }}"
          fi

          # Set environment variables based on branch
          case "$BRANCH_REF" in
            "refs/heads/develop")
              echo "STAGE=dev" >> $GITHUB_OUTPUT
              echo "CONTAINER_NAME=container-app-bot-dev" >> $GITHUB_OUTPUT
              echo "BOT_TOKEN_SECRET=dev-bot-token" >> $GITHUB_OUTPUT
              echo "IMAGE_TAG=dev-latest" >> $GITHUB_OUTPUT
              echo "IS_PROD=false" >> $GITHUB_OUTPUT
              echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
              echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
              echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
              ;;
            "refs/heads/test")
              echo "STAGE=test" >> $GITHUB_OUTPUT
              echo "CONTAINER_NAME=container-app-bot-test" >> $GITHUB_OUTPUT
              echo "BOT_TOKEN_SECRET=test-bot-token" >> $GITHUB_OUTPUT
              echo "IMAGE_TAG=test-latest" >> $GITHUB_OUTPUT
              echo "IS_PROD=false" >> $GITHUB_OUTPUT
              echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
              echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
              echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
              ;;
            "refs/heads/master")
              echo "STAGE=staging" >> $GITHUB_OUTPUT
              echo "CONTAINER_NAME=container-app-bot-staging" >> $GITHUB_OUTPUT
              echo "BOT_TOKEN_SECRET=master-bot-token" >> $GITHUB_OUTPUT
              echo "IMAGE_TAG=staging-latest" >> $GITHUB_OUTPUT
              echo "IS_PROD=false" >> $GITHUB_OUTPUT
              echo "CONTAINER_APP_NAME=${{ env.BRANCHED_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
              echo "MIN_REPLICAS=0" >> $GITHUB_OUTPUT
              echo "MAX_REPLICAS=5" >> $GITHUB_OUTPUT
              ;;
            "refs/heads/prod")
              echo "STAGE=prod" >> $GITHUB_OUTPUT
              echo "CONTAINER_NAME=container-app-bot-prod" >> $GITHUB_OUTPUT
              echo "BOT_TOKEN_SECRET=bottokern" >> $GITHUB_OUTPUT
              echo "IMAGE_TAG=prod-latest" >> $GITHUB_OUTPUT
              echo "IS_PROD=true" >> $GITHUB_OUTPUT
              echo "CONTAINER_APP_NAME=${{ env.PROD_CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT
              echo "MIN_REPLICAS=1" >> $GITHUB_OUTPUT
              echo "MAX_REPLICAS=10" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Error: Unsupported branch" >> $GITHUB_OUTPUT
              exit 1
              ;;
          esac

          # Set release tag for other events
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "RELEASE_TAG=pushed-into-${{ github.ref_name }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "RELEASE_TAG=merged-into-${{ github.base.ref }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" != "release" ]; then
            echo "RELEASE_TAG=manual-trigger" >> $GITHUB_OUTPUT
          fi


          echo "=== Deployment Information ==="
          echo "STAGE: ${{ steps.set_deployment_info.outputs.STAGE }}"
          echo "CONTAINER_NAME: ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}"
          echo "CONTAINER_APP_NAME: ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }}"
          echo "IMAGE_TAG: ${{ steps.set_deployment_info.outputs.IMAGE_TAG }}"
          echo "RELEASE_TAG: ${{ steps.set_deployment_info.outputs.RELEASE_TAG }}"
          echo "IS_PROD: ${{ steps.set_deployment_info.outputs.IS_PROD }}"
          echo "EVENT_NAME: ${{ github.event_name }}"
          echo "REF: ${{ github.ref }}"
          echo "=========================="


          

      - name: Build and push image to ACR
        run: |
          # Clean up old images with the same tag
          az acr repository delete \
            --name ${{ env.ACR_NAME }} \
            --image ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
            --yes || true

          # Build and push new image
          az acr build \
            --registry ${{ env.ACR_NAME }} \
            --image ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
            --file Dockerfile \
            .


      

      
  
    
      - name: Deploy Container App
        run: |
              # Get timestamp for new revision
              TIMESTAMP=$(date +%Y%m%d-%H%M%S)
              REVISION_SUFFIX="${{ steps.set_deployment_info.outputs.STAGE }}-${TIMESTAMP}"
              
              # Calculate scale down time (15 minutes from now)
              SCALE_MINUTE=$((($(date +%M) + 15) % 60))
              SCALE_HOUR=$(($(date +%H) + ($(date +%M) + 15) / 60))
              SCALE_HOUR=$((SCALE_HOUR % 24))
              START_CRON="$SCALE_MINUTE $SCALE_HOUR * * *"
              
              echo "Scale down scheduled for: $START_CRON UTC"
              echo "Starting deployment for revision: ${REVISION_SUFFIX}"
              
              if [ "${{ steps.set_deployment_info.outputs.IS_PROD }}" != "true" ]; then
                # For non-prod environments - first deploy without scale rules
                echo "Deploying non-prod environment..."
                az containerapp update \
                  --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --revision-suffix "${REVISION_SUFFIX}" \
                  --min-replicas 1 \
                  --max-replicas ${{ steps.set_deployment_info.outputs.MAX_REPLICAS }} \
                  --container-name ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }} \
                  --image ${{ env.ACR_NAME }}.azurecr.io/${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
                  --cpu 0.5 \
                  --memory 1.0Gi \
                  --set-env-vars \
                    RELEASE_TAG=${{ steps.set_deployment_info.outputs.RELEASE_TAG }} \
                    STAGE=${{ steps.set_deployment_info.outputs.STAGE }} \
                    PYTHONUNBUFFERED=1 \
                    BOT_TOKEN=secretref:${{ steps.set_deployment_info.outputs.BOT_TOKEN_SECRET }} \
                    API_ID=secretref:${{ steps.set_deployment_info.outputs.IS_PROD == 'true' && 'apiid' || 'api-id' }} \
                    API_HASH=secretref:${{ steps.set_deployment_info.outputs.IS_PROD == 'true' && 'apihash' || 'api-hash' }}
    
                echo "Waiting for initial deployment to stabilize..."
                for i in {1..6}; do
                  echo "Checking deployment status (attempt $i)..."
                  DEPLOYMENT_STATUS=$(az containerapp revision list \
                    -n ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                    -g ${{ env.RESOURCE_GROUP }} \
                    --query "[?contains(name, '${REVISION_SUFFIX}')].{Status:properties.status}" -o tsv)
                  
                  if [ "$DEPLOYMENT_STATUS" == "Running" ]; then
                    echo "✅ Deployment is running"
                    break
                  fi
                  
                  if [ $i -eq 6 ]; then
                    echo "❌ Deployment failed to stabilize"
                    exit 1
                  fi
                  
                  echo "Waiting for deployment to stabilize..."
                  sleep 30
                done
    
                # Then apply scale rules in a separate update
                echo "Applying scale rules..."
                az containerapp update \
                  --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --scale-rule-name "scale-to-zero" \
                  --scale-rule-type "cron" \
                  --scale-rule-metadata \
                    "start=$START_CRON" \
                    "timezone=UTC" \
                    "desiredReplicas=0"
              else
                # Production deployment without scale rules
                echo "Deploying production environment..."
                az containerapp update \
                  --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --revision-suffix "${REVISION_SUFFIX}" \
                  --min-replicas 1 \
                  --max-replicas ${{ steps.set_deployment_info.outputs.MAX_REPLICAS }} \
                  --container-name ${{ steps.set_deployment_info.outputs.CONTAINER_NAME }} \
                  --image ${{ env.ACR_NAME }}.azurecr.io/${{ steps.set_deployment_info.outputs.CONTAINER_NAME }}:${{ steps.set_deployment_info.outputs.IMAGE_TAG }} \
                  --cpu 0.5 \
                  --memory 1.0Gi \
                  --set-env-vars \
                    RELEASE_TAG=${{ steps.set_deployment_info.outputs.RELEASE_TAG }} \
                    STAGE=${{ steps.set_deployment_info.outputs.STAGE }} \
                    PYTHONUNBUFFERED=1 \
                    BOT_TOKEN=secretref:${{ steps.set_deployment_info.outputs.BOT_TOKEN_SECRET }} \
                    API_ID=secretref:${{ steps.set_deployment_info.outputs.IS_PROD == 'true' && 'apiid' || 'api-id' }} \
                    API_HASH=secretref:${{ steps.set_deployment_info.outputs.IS_PROD == 'true' && 'apihash' || 'api-hash' }}
              fi
              
              # Verify deployment
              echo "Verifying deployment..."
              MAX_RETRIES=6
              RETRY_COUNT=0
              
              while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                echo "Verification attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"
                
                ACTIVE_REVISIONS=$(az containerapp revision list \
                  -n ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                  -g ${{ env.RESOURCE_GROUP }} \
                  --query "[?properties.active].{name:name, status:properties.status, replicas:properties.replicas}" -o json)
                
                echo "Current active revisions:"
                echo "$ACTIVE_REVISIONS" | jq '.'
                
                # Check if our new revision exists and is active
                if echo "$ACTIVE_REVISIONS" | jq -e ".[] | select(.name | contains(\"${REVISION_SUFFIX}\"))" > /dev/null; then
                  echo "✅ Deployment verified successfully"
                  REVISION_STATUS=$(echo "$ACTIVE_REVISIONS" | jq -r ".[] | select(.name | contains(\"${REVISION_SUFFIX}\")).status")
                  echo "New revision status: $REVISION_STATUS"
                  
                  # Only proceed with cleanup if the new revision is active
                  if [ "$REVISION_STATUS" == "Running" ]; then
                    echo "Cleaning up old revisions..."
                    while IFS= read -r revision; do
                      if [ -n "$revision" ] && [[ "$revision" != *"${REVISION_SUFFIX}"* ]]; then
                        echo "Deactivating old revision: $revision"
                        az containerapp revision deactivate \
                          --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                          --resource-group ${{ env.RESOURCE_GROUP }} \
                          --revision "$revision"
                      fi
                    done <<< "$(echo "$ACTIVE_REVISIONS" | jq -r '.[].name')"
                    break
                  fi
                fi
                
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "❌ Deployment verification failed after $MAX_RETRIES attempts"
                  exit 1
                fi
                
                echo "Waiting 30 seconds before next verification attempt..."
                sleep 30
              done
              
              # Final configuration verification
              echo "Verifying final configuration..."
              az containerapp show \
                --name ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --query "{scale:properties.template.scale, activeRevisionMode:properties.configuration.activeRevisionsMode}" -o json
                  


      - name: Verify Deployment
        run: |
              echo "Verifying deployment..."
              
              # Wait for deployment to stabilize
              sleep 90
              
              # Get current active revisions
              ACTIVE_REVISIONS=$(az containerapp revision list \
                -n ${{ steps.set_deployment_info.outputs.CONTAINER_APP_NAME }} \
                -g ${{ env.RESOURCE_GROUP }} \
                --query "[?properties.active].{name:name, replicas:properties.replicas}" -o json)
              
              echo "Current active revisions:"
              echo "$ACTIVE_REVISIONS" | jq '.'
              
              # Define expected values
              SUFFIX_PATTERN="${{ steps.set_deployment_info.outputs.STAGE }}-"
              
              echo "Looking for revision with pattern: $SUFFIX_PATTERN"
              
              # Verify deployment based only on the revision name pattern
              if echo "$ACTIVE_REVISIONS" | jq -e ".[] | select(.name | contains(\"$SUFFIX_PATTERN\"))" > /dev/null; then
                echo "✅ Deployment verified successfully"
                echo "Active revision details:"
                echo "$ACTIVE_REVISIONS" | jq ".[] | select(.name | contains(\"$SUFFIX_PATTERN\"))"
              else
                echo "❌ Deployment verification failed"
                echo "Debug information:"
                echo "Expected suffix pattern: $SUFFIX_PATTERN"
                echo "All active revisions:"
                echo "$ACTIVE_REVISIONS" | jq '.'
                exit 1
              fi